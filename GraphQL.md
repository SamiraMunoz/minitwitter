# GraphQL

Over the years the rest APIs became a standard for the development of any application, however, as applications evolve the way of obtaining data from our APIs also evolves, it became evident the need to create a tool that was flexible and efficient, thus emerged GraphQL, whose objective is the manipulation and collection of data. One of the notorious differences between the API rest and GraphQL is in the obtaining of the data, normally for the API rest we must access multiple endpoints to obtain all the necessary information, while, for GraphQL it is only necessary to send the query to the GraphQL server to obtain it.

Taking as an example in a blogging application, an app needs to display the titles of the posts of a specific user. The same screen also displays the names of the last 3 followers of that user, using API rest we must have three endpoints, one to obtain the user information, another to list the latest posts and another to returns a list of followers per user, instead, with GraphQL obtaining the information can be done with a single query.

[API rest](img/api_rest.png)

[GraphQL](img/GraphQL.png)

## Getting start

1. Add in your gemfile `gem install graphql`.
2. Add in your gemfile `gem "graphiql-rails` in develomept.
3. Execute `bundle install`.
4. Execute `rails generate graphql:install` to initialize graphql in your project.
5. Add in your routes:
  ```bash
    if Rails.env.development?
      mount GraphiQL::Rails::Engine, at: "/graphiql", graphql_path: "graphql#execute"
    end
  ```
6. Add in your config/application.rb
  ```bash
    require "sprockets/railtie"
  ```
7. Create a folder app/assets/config, create a file manifest.js and add:
  ```bash
    //= link graphiql/rails/application.css
    //= link graphiql/rails/application.js
  ```
8. Download the application [GraphiQL](https://github.com/skevy/graphiql-app) to test your mutations and queries.
6. Run server
7. Open the GraphiQL application and execute the endpoint. `http://localhost:3000/graphql`, here you will find your mutilations and queries.
8. You are ready to create your mutations and queries with GraphQL.


## Working with GraphQL

### Mutations

GraphQL mutations are special fields: instead of reading data or performing calculations, they may modify the application state. For example, mutation fields may:

* Create, update or destroy records in the database
* Establish associations between already-existing records in the database
* Increment counters
* Create, modify or delete files
* Clear caches

### Queries

GraphQL queries are used for fetch data, the query will be exactly the same as the result, fetching only the requested fields.

### Type

Describe objects in your application, each object has fields which expose data and may be queried by name. Example we can have a user class that has several tweets, the User object would look like this :
  ```bash
    module Objects
      class UserObject < Types::BaseObject
        field :id, ID, null: false
        field :first_name, String, null: true
        field :last_name, String, null: true
        field :tweets, [Objects::TweetObject], null: true
      end
    end
  ```

## CRUD GraphQL

Before starting with the CRUD you must create some files that will serve as the basis for the queries and mutations.

1. Create a folder in app/graphql with the name mutations.
2. Create a folder in app/graphql with the name queries.
3. Create a folder in app/graphql with the name objects.
4. Create a folder in app/graphql/types with the name input.
5. Create file in the mutations folder with the name base_mutation.rb and add:
  ```bash
    module Mutations
      class BaseMutation < GraphQL::Schema::RelayClassicMutation
        argument_class Types::BaseArgument
        field_class Types::BaseField
        input_object_class Types::BaseInputObject
        object_class Types::BaseObject
      end
    end
  ```
6. Create file in the queries folder with the name base_query.rb and add:
  ```bash
    module Queries
      class BaseQuery < GraphQL::Schema::Resolver
      end
    end
  ```
7. Create a file with the name of the model representing the type of object and the fields it has. For the example we will have a user model with the fields first_name, last_name and nickname.
  ```bash
    module Objects
      class UserObject < Types::BaseObject
        field :id, ID, null: false
        field :first_name, String, null: true
        field :last_name, String, null: true
        field :nickname, String, null: false
        field :created_at, GraphQL::Types::ISO8601DateTime, null: false
        field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
        field :full_name, String, null: true
      end
    end
  ```

### Create

1. Run `rails g graphql:mutation create_user`
2. Modify line generated by command in mutation_type.rb file.
  ```bash
    From
    field :create_user, mutation: Mutations::CreateUser
    To
    # Define what type of value to be returned and add a description
    field :create_user, Objects::UserObject, mutation: Mutations::User::Create, description: 'Create a user'
  ```
3. Create a user_input_type.rb file to define the attributes required to create or update a user.
  ```bash
    module Types
      module Input
        class UserInputType < Types::BaseInputObject
          graphql_name "UserInputType"

          argument :id, ID, required: false
          argument :first_name, String, required: false
          argument :last_name, String, required: false
          argument :nickname, String, required: false
        end
      end
    end
  ```
4. Modify mutations/create_user.rb
  ```bash
    module Mutations
      class Create < GraphQL::Schema::Mutation
        # Define what argument this mutation accepts
        argument :user, Types::Input::UserInputType, required: true

        # Standard name of the method to obtain what is to be resolved with class
        def resolve(user:)
          user_params = Hash user
          begin
            ::User.create!(user_params)
          rescue ActiveRecord::RecordInvalid => e
            GraphQL::ExecutionError.new("Invalid attributes for #{e.record.class}:"\
              " #{e.record.errors.full_messages.join(', ')}")
          end
        end
      end
    end
  ```
5. Test in grahpiql
  ```bash
    mutation createUser($user: UserInputType!){
      createUser(user: $user){
        id
        fullName
      }
    }

    Query Values:

    {
      "user": {
        "firstName": "James",
        "lastName": "Rodriguez 2.0",
        "nickname": "JamesRodriguez"
      }
    }
  ```

### Read

1. Add in app/graphql/types/query_type.rb
  ```bash
    field :fetch_users, resolver: Queries::Users::FetchUsers
    field :fetch_user, resolver: Queries::Users::FetchUser
  ```
2. Create file fetch_user.rb in app/graphql/queries/users and add:
  ```bash
    module Queries
      module Users
        class FetchUser < Queries::BaseQuery
          type Objects::UserObject, null: false
          argument :id, ID, required: true

          def resolve(id:)
            User.find(id)
          rescue ActiveRecord::RecordNotFound => _e
            GraphQL::ExecutionError.new('User does not exist.')
          rescue ActiveRecord::RecordInvalid => e
            GraphQL::ExecutionError.new("Invalid attributes for #{e.record.class}:"\
              " #{e.record.errors.full_messages.join(', ')}")
          end
        end
      end
    end
  ```
2. Create file fetch_users.rb in app/graphql/queries/users and add:
  ```bash
    module Queries
      module Users
        class FetchUsers < Queries::BaseQuery

          type [Objects::UserObject], null: false

          def resolve
            User.all.order(created_at: :desc)
          end
        end
      end
    end
  ```
3. Test in grahpiql
  ```bash
    # Fetch users
    query {
      fetchUsers {
        id
        firstName
        lastName
        nickname
      }
    }

    # Fetch user, you need to pass the id as a parameter
    query {
      fetchUser(id: 1) {
        id
        firstName
        lastName
        nickname
      }
    }

  ```

### Update

1. Run `rails g graphql:mutation update_user`
2. Modify line generated by command in mutation_type.rb file.
  ```bash
    From
    field :update_user, mutation: Mutations::UpdateUser
    To
    # Define what type of value to be returned and add a description
    field :update_user, Objects::UserObject, mutation: Mutations::UpdateUser, description: 'Update a user'
  ```
3. Create a user_input_type.rb file to define the attributes required to create or update a user.
  ```bash
    module Types
      module Input
        class UserInputType < Types::BaseInputObject
          graphql_name "UserInputType"

          argument :id, ID, required: false
          argument :first_name, String, required: false
          argument :last_name, String, required: false
          argument :nickname, String, required: false
        end
      end
    end
  ```
4. Modify mutations/update_user.rb
  ```bash
    module Mutations
      class UpdateUser < GraphQL::Schema::Mutation
        argument :user, Types::Input::UserInputType, required: true

        def resolve(user:)
          user_params = Hash user
          id = user_params[:id]

          begin
            find_user(id).update(user_params)
            @user
          rescue ActiveRecord::RecordInvalid => e
            GraphQL::ExecutionError.new("Invalid attributes for #{e.record.class}:"\
              " #{e.record.errors.full_messages.join(', ')}")
          end
        end

        def find_user(id)
          @user ||= ::User.find(id)
        end
      end
    end
  ```
5. Test in grahpiql
  ```bash
    mutation updateUser($user: UserInputType!){
      updateUser(user: $user){
        id
        fullName
      }
    }

    Query Values:

    {
      "user": {
        "id": "1",
        "firstName": "James"
      }
    }
  ```

### Delete

1. Run `rails g graphql:mutation destroy_user`
3. Modify mutations/destroy_user.rb
  ```bash
    module Mutations
      class DestroyUser < GraphQL::Schema::Mutation
        field :id, ID, null: true
        argument :id, ID, required: true

        def resolve(id:)
          ::User.find(id).destroy
          {
            id: id,
          }
        end
      end
    end
  ```
4. Test in grahpiql
  ```bash
    # You need to pass the id as a parameter
    mutation{
      destroyUser(id: 1){
        id
      }
    }
  ```


## Pagination

Add in your gemfile

```bash
  gem 'graphql-pagination'
  gem 'kaminari-activerecord'
```

Usage example

* Change your fetch_users.rb file by adding the page and limit argument.
  ```bash
    module Queries
      module Users
        class FetchUsers < Queries::BaseQuery

          argument :page, Integer, required: false
          argument :limit, Integer, required: false

          type Objects::UserObject.collection_type, null: true

          def resolve(page: nil, limit: nil)
            User.all.order(created_at: :desc).page(page).per(limit)
          end
        end
      end
    end
  ```
* Test in grahpiql
  ```bash
    {
      fetchUsers(page: 1, limit: 2) {
        collection {
          id
          firstName
          lastName
          nickname
          email
        }
        metadata {
          totalPages
          totalCount
          currentPage
          limitValue
        }
      }
    }
  ```

## Solve N+1

Add in your gemfile

```bash
  gem 'graphql-batch'
```

Implementation

1. Require the library in your graphql schema `require 'graphql/batch'`.
2. Add `use GraphQL::Batch` in your graphql schema.
  ```bash
    class MySchema < GraphQL::Schema
      query MyQueryType
      mutation MyMutationType

      use GraphQL::Batch
    end
  ```
3. Create a custom loader in the graphql folder with name record_loader.rb and add:
  ```bash
    class RecordLoader < GraphQL::Batch::Loader
      def initialize(model)
        @model = model
      end

      def perform(ids)
        @model.where(id: ids).each { |record| fulfill(record.id, record) }
        ids.each { |id| fulfill(id, nil) unless fulfilled?(id) }
      end
    end
  ```
4. Use the loader in your objects to load them by passing the object id as parameter.
  ```bash
    module Objects
      class TweetObject < Types::BaseObject
        field :id, ID, null: false
        field :content, String, null: false
        field :author, Objects::UserObject, null: false
        field :created_at, GraphQL::Types::ISO8601DateTime, null: false
        field :updated_at, GraphQL::Types::ISO8601DateTime, null: false

        def author
          RecordLoader.for(::User).load(object.author_id)
        end
      end
    end
  ```
